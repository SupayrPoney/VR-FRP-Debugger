<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>
    {{title}}
    </title>
    <meta name="description" content="Hello, World! - A-Frame">
    <link rel="stylesheet" type="text/css" href="stylesheet.css">
    <script src="https://aframe.io/releases/0.3.2/aframe.min.js"></script>
    <script src="https://rawgit.com/bryik/aframe-bmfont-text-component/master/dist/aframe-bmfont-text-component.min.js"></script>
    <script src="https://rawgit.com/andreasplesch/aframe-meshline-component/master/dist/aframe-meshline-component.min.js"></script>
    <script type="text/javascript">
        var signalGraph = ""
        function sleep(milliseconds) {
            var start = new Date().getTime();
            for (var i = 0; i < 1e7; i++) {
                if ((new Date().getTime() - start) > milliseconds){
                    break;
            }
          }
        }
        function start() {
            signalGraph = JSON.parse(document.getElementById("graph").innerHTML);
            var nodeTest = document.querySelector('#\\3' + 2);
            // nodeTest.setAttribute('bmfont-text', "coucou");
            handle_signals(signalGraph);
        }

        var secondSignalEnabled = true;
        var signal = "seconds";

        function updateNode(node){
            function render(color) {
                // requestAnimationFrame(render);
                circle.setAttribute('color', color);
            }
            var sceneEl = document.querySelector('a-scene');
            var reached = false;
            var entityEl;

            // VALUES FLOWING       
            // for (var i = 0; i < node.children.length; i++) {
                
            //     var fromDest = document.querySelector('#\\3' + node.id).getAttribute('position');
            //     var toDest = document.querySelector('#\\3' + node.children[i].id).getAttribute('position');

            //     entityEl = document.createElement('a-entity');
            //     var dist = {
            //         x:(toDest.x - fromDest.x),
            //         y:(toDest.y - fromDest.y)
            //     }
            //     var deltaX = dist.x/50;
            //     var deltaY = dist.y/50;

            //     entityEl.setAttribute('bmfont-text', "text:coucou");
            //     entityEl.setAttribute('position', fromDest.x + " " + fromDest.y +" " + fromDest.z)
            //     entityEl.addEventListener('move', function (event) {
            //         sleep(20);
            //         var currentPos = entityEl.getAttribute("position");
            //         // console.log("yo")
            //         entityEl.setAttribute('position', (currentPos.x-deltaX) + " " + (currentPos.y+deltaY) +" " + currentPos.z);
            //     });

            //     for (var i = 0; i < 50; i++) {
            //         // console.log(fromDest.x-deltaX*i);
            //         entityEl.emit("move")
                    
            //     }
                

                // console.log("From: ");
                // console.log(fromDest);
                // console.log("To: ");
                // console.log(toDest);
                // node.children[i];
            }

            sceneEl.appendChild(entityEl);
            var circle = document.querySelector("[id='"+ node.id + "0000"+ "']"); //#\\3' + node.id + "0000");
            // console.log(circle);//'#\\320000');// + node.id + "0000");
            render('blue');

            var nodeTest = document.querySelector('#\\3' + node.id);
            // console.log('#\\3' + node.id);
            var nodeText = nodeTest.getAttribute('bmfont-text').text;
            // console.log(nodeText.split(" ")[0]);
            var newNodeText = "text:" + node.name +'\n'+ node.value.toString();//nodeTest.setAttribute('bmfont-text',
            nodeTest.setAttribute('bmfont-text', newNodeText);


            render('black');
            // var t = 0;
            // var colors = ['black',"orange"]
            // function render() {
            //   t = 1- t;
            //   requestAnimationFrame(render);
            //   ring.setAttribute('color', colors[t]);
            // }
            // render();
        }
        
        function handle_signals(signalGraph) {
            if (secondSignalEnabled) {
                setInterval(function(){ 
                    // console.log(signalGraph)
                    signalGraph[signal].value ++;
                    updateNode(signalGraph[signal]);
                    for (var i = 0; i < signalGraph.seconds.children.length; i++) {
                        node = signalGraph.seconds.children[i];
                        switch(node.name){
                            case "fold":
                                node.value = eval(node.formula.replace("$$signalValue$$",signalGraph[signal].value).replace("currentValue",node.value));
                                updateNode(node);
                                break;
                            case "map":
                                [body,param] = node.formula;
                                node.value = eval(body.replace(param, signalGraph[signal].value));
                                updateNode(node);
                                break;
                            case "filter":
                                [body,param] = node.formula;
                                signalValue = signalGraph[signal].value
                                if (eval(body.replace(param, signalValue))) {
                                    node.value = signalValue;
                                }
                                updateNode(node);
                                break;

                        }
                     }   
                }, 1000);
            }
        }
    </script>

</head>
<body onload=start()>
    <a-scene id = "scene">
        {{scene}}
    </a-scene>
    <div id="graph" style="display: none;">
        {{graph}}
    </div>
</body>
</html>
