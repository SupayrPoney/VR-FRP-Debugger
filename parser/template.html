<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>
    {{title}}
    </title>
    <meta name="description" content="Hello, World! - A-Frame">
    <link rel="stylesheet" type="text/css" href="stylesheet.css">
    <script src="https://aframe.io/releases/0.3.2/aframe.min.js"></script>
    <script src="//cdn.rawgit.com/donmccurdy/aframe-extras/v3.3.1/dist/aframe-extras.misc.min.js"></script><!-- For controllers -->
    <script src="https://rawgit.com/bryik/aframe-bmfont-text-component/master/dist/aframe-bmfont-text-component.min.js"></script>
    <script src="https://rawgit.com/andreasplesch/aframe-meshline-component/master/dist/aframe-meshline-component.min.js"></script>
    <script type="text/javascript">
        var signalGraph = ""
        function sleep(milliseconds) {
            var start = new Date().getTime();
            for (var i = 0; i < 1e7; i++) {
                if ((new Date().getTime() - start) > milliseconds){
                    break;
            }
          }
        }
        function findSignalNode(signalGraph, signalName) {
            function searchInNode(node, signalName) {
                // console.log(node);
                if (node.ref == signalName) {
                    return node;
                }
                else if (node.children) {
                    var i;
                    var result = null;
                    for(i = 0; result == null && i < node.children.length; i++){
                        result = searchInNode(node.children[i], signalName);
                   }
                   return result;
                }
                return null;
            }
            var i;
            var result = null;
            var keys = Object.keys(signalGraph);
            for (i = 0; result == null && i < keys.length; i++){
                // console.log(signalGraph);
                if (signalGraph[keys[i]].ref ==signalName ) {
                    result = signalGraph[keys[i]];
                }
                else{
                    result = searchInNode(signalGraph[keys[i]], signalName);
                }
            }
            return result;
        }
        function start() {
            signalGraph = JSON.parse(document.getElementById("graph").innerHTML);
            var nodeTest = document.querySelector('#\\3' + 2);
            // nodeTest.setAttribute('bmfont-text', "coucou");
            handle_signals(signalGraph);
        }

        var secondSignalEnabled = true;
        var signal = "seconds";

        function updateNode(node){
            function render(color) {
                // requestAnimationFrame(render);
                circle.setAttribute('color', color);
            }
            var sceneEl = document.querySelector('a-scene');
            var reached = false;
            var entityEl;

            // VALUES FLOWING       
            // for (var i = 0; i < node.children.length; i++) {
                
            //     var fromDest = document.querySelector('#\\3' + node.id).getAttribute('position');
            //     var toDest = document.querySelector('#\\3' + node.children[i].id).getAttribute('position');

            //     entityEl = document.createElement('a-entity');
            //     var dist = {
            //         x:(toDest.x - fromDest.x),
            //         y:(toDest.y - fromDest.y)
            //     }
            //     var deltaX = dist.x/50;
            //     var deltaY = dist.y/50;

            //     entityEl.setAttribute('bmfont-text', "text:coucou");
            //     entityEl.setAttribute('position', fromDest.x + " " + fromDest.y +" " + fromDest.z)
            //     entityEl.addEventListener('move', function (event) {
            //         sleep(20);
            //         var currentPos = entityEl.getAttribute("position");
            //         // console.log("yo")
            //         entityEl.setAttribute('position', (currentPos.x-deltaX) + " " + (currentPos.y+deltaY) +" " + currentPos.z);
            //     });

            //     for (var i = 0; i < 50; i++) {
            //         // console.log(fromDest.x-deltaX*i);
            //         entityEl.emit("move")
                    
            //     }
                

                // console.log("From: ");
                // console.log(fromDest);
                // console.log("To: ");
                // console.log(toDest);
                // node.children[i];
            

            // sceneEl.appendChild(entityEl);
            var circle = document.querySelector("[id='"+ node.id + "0000"+ "']"); //#\\3' + node.id + "0000");
            // console.log(circle);//'#\\320000');// + node.id + "0000");
            render('blue');

            var nodeTest = document.querySelector('#\\3' + node.id);
            // console.log('#\\3' + node.id);
            var nodeText = nodeTest.getAttribute('bmfont-text').text;
            // console.log(nodeText.split(" ")[0]);
            var newNodeText = "text:" + node.name +'\n'+ node.value.toString();//nodeTest.setAttribute('bmfont-text',
            nodeTest.setAttribute('bmfont-text', newNodeText);


            render('black');
            // var t = 0;
            // var colors = ['black',"orange"]
            // function render() {
            //   t = 1- t;
            //   requestAnimationFrame(render);
            //   ring.setAttribute('color', colors[t]);
            // }
            // render();
        }

        function update_children(parentNode, graph){
            console.log("Cocou",graph);
            if (parentNode.children) {
                for (var i = 0; i < parentNode.children.length; i++) {
                    node = parentNode.children[i];
                    switch(node.name){
                        case "fold":
                            node.value = eval(node.formula.replace("$$signalValue$$",parentNode.value).replace("currentValue",node.value));
                            updateNode(node);
                            break;
                        case "map":
                            [body,param] = node.formula;
                            node.value = eval(body.replace(param, parentNode.value));
                            updateNode(node);
                            break;
                        case "filter":
                            [body,param] = node.formula;
                            signalValue = parentNode.value
                            if (eval(body.replace(param, signalValue))) {
                                node.value = signalValue;
                            }
                            updateNode(node);
                            break;
                        case "merge":
                            [signal1, signal2, operator] = node.formula;
                            // console.log(signalGraph);
                            signal1Value = findSignalNode(graph,signal1).value;
                            // console.log(signal1Value)
                            signal2Value = findSignalNode(graph,signal2).value;
                            node.value = eval(signal1Value + operator + signal2Value);
                            
                            updateNode(node);
                            break;


                    }
                    update_children(node, graph);
                }
            }
        }
        
        function handle_signals(signalGraph) {
            if (secondSignalEnabled) {
                setInterval(function(){ 
                    // console.log(signalGraph)
                    signalGraph[signal].value ++;
                    updateNode(signalGraph[signal]);

                    // console.log(signalGraph);
                    this.update_children(signalGraph[signal], signalGraph);   
                }, 1000);
            }
        }
    </script>

</head>
<body onload=start()>
    <a-scene id = "scene">
        {{scene}}
    </a-scene>
    <div id="graph" style="display: none;">
        {{graph}}
    </div>
</body>
</html>
